<!DOCTYPE html>	
<html>
	<head id="header">
		<meta name="viewport" content="user-scalable=no, width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
	    <meta name="apple-mobile-web-app-capable" content="yes" />
	    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
		<title>Block Racer</title>
		<script src="js/jquery.js"></script>
		
		<style type="text/css">
			html { background: black; }
			#details { margin: 0 auto; width: 1240px; margin-top: 25px; } 
			#game { margin: 0 auto; margin-top: 10px; width: 1000px; height: 750px; }
			#playerID { color: white; font-family: Verdana; }
			img { display: none; }
			#nameVal, #saveName { border: none; padding: 10px; }
			#saveName { background-color: green; color: white; cursor: pointer;}
			#you { font-family: Arial; color: white; font-weight: bold; font-size: 14px; margin-left: 30px;}
		</style>
		
	</head>
	<body>
	
		<div id="details">				
			What is your name <input type="text" value="" name="name" id="nameVal" autocomplete="off" placeholder="Your name"/> <input type="submit" name="submit" id="saveName" value="Go" /><span id="you"></span>			
		</div>
		
		<img id="carBitmap" src="cars.png" />
		<div id="game"></div>
	
		<script src="http://localhost:8080/socket.io/socket.io.js"></script>
		<script src="maths.js" type="text/javascript"></script>
		<script src="particleEngine.js" type="text/javascript"></script>
		<script type="text/javascript">
			var drawString = function (textIn,xIn,yIn, sizeIn) {
				ctx.fillStyle= "white";				
				ctx.font="bold "+ sizeIn+ "px Arial";
				ctx.textBaseline = "bottom";
				ctx.fillText(textIn, xIn, yIn);
			}	
			
			function roundNumber(num, dec) {
				return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
			}
			$("#nameVal").focus();
			
			var carBitmap = new Image();
			carBitmap = document.getElementById("carBitmap");
			var playerlist = [];	
			var playerJoinList = [];// Store players who joined
			var netTimer = 10;
			
			var canvas = document.createElement("canvas");
				
			// FPS 
			var lastTime;
			var frames;
			var totalTime;
			var updateTime;
			var updateFrames;
			var lastCurAmount;
			var curAmount;	
			
			var debugToggle = true;
			var collisionColor = "cornflowerblue";
			
			// End FPS
			
			var playerSpeed = 1, playerSize = 10;
			var playerName = null;				
			ctx = null;			
			var height = 700, width = 1000, then = Date.now(), mousePosition = {x:0, y:0};
			
			var requestAnimFrame =  window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(/* function */ callback){
				window.setTimeout(callback, 1000 / 60);
			};
			
			var KEYNAMES = {'LEFT' : 0, 'RIGHT' : 1, 'UP' : 2, 'DOWN': 3,'SPACE':4 }; 
			var KEY = {'BACKSPACE': 8, 'TAB': 9, 'NUM_PAD_CLEAR': 12, 'ENTER': 13, 'SHIFT': 16, 'CTRL': 17, 'ALT': 18, 'PAUSE': 19, 'CAPS_LOCK': 20, 'ESCAPE': 27,'SPACEBAR': 32, 'PAGE_UP': 33, 'PAGE_DOWN': 34, 'END': 35, 'HOME': 36, 'ARROW_LEFT': 37, 'ARROW_UP': 38, 'ARROW_RIGHT': 39, 'ARROW_DOWN': 40,'PRINT_SCREEN': 44, 'INSERT': 45, 'DELETE': 46, 'SEMICOLON': 59,'WINDOWS_LEFT': 91, 'WINDOWS_RIGHT': 92, 'SELECT': 93,'NUM_PAD_ASTERISK': 106, 'NUM_PAD_PLUS_SIGN': 107,	'NUM_PAD_HYPHEN-MINUS': 109, 'NUM_PAD_FULL_STOP': 110,'NUM_PAD_SOLIDUS': 111, 'NUM_LOCK': 144, 'SCROLL_LOCK': 145,'EQUALS_SIGN': 187, 'COMMA': 188, 'HYPHEN-MINUS': 189,'FULL_STOP': 190, 'SOLIDUS': 191, 'GRAVE_ACCENT': 192,'LEFT_SQUARE_BRACKET': 219, 'REVERSE_SOLIDUS': 220,'RIGHT_SQUARE_BRACKET': 221, 'APOSTROPHE': 222, 'M' : 77 };
									
			function Player(name, x,y, frame) {
				this.x = x;
				this.y = y;
				this.vx = 0.0;
				this.vy = 0.0;				
				this.topSpeed = 3.5;	
				this.topSpeedRev = -2;
				this.friction = 0.05;		
				this.acc = 0.15;
				this.speed = 0.0;				
				this.name = name;
				this.frame = frame;
				this.angle = 0;
				this.reverse = 0.1;
				this.width = 14;
				this.height = 24;				
				this.handle = 3;
				this.brake = 0.25;
				this.skidSpeed = 2.0;
				this.skidding = false;

			//	this.isBraking = 0; // 0 = NO, 1 = YES;
				this.keys = [];
				this.keys[KEYNAMES.LEFT] = false; // left
				this.keys[KEYNAMES.RIGHT] = false; // right
				this.keys[KEYNAMES.UP] = false; // up
				this.keys[KEYNAMES.DOWN] = false; // down	
				this.keys[KEYNAMES.SPACE] = false;
				
				this.leftAllowed = this.rightAllowed = this.upAllowed = this.downAllowed = this.spaceAllowed = true;
			}
			
			$("#nameVal").keyup(function(e) {
				if (e.keyCode == 13) {
					$("#saveName").click();
				}
			});
			
			var toggleOnce = false;
			$("#saveName").click(function() {				
				if (toggleOnce) { location.reload(true); return false; }
				toggleOnce = true;
				playerName = $("#nameVal").val() + Math.floor(Math.random() * 101);
				$(this).attr("value", "Refresh");				
				runGame();
			});
			
			function runGame() {					
				document.getElementById("you").innerHTML = "You are " + playerName;				
				var socket = null;
				
				try {
					socket = io.connect("http://localhost:8080");				
				}catch (err) {
					alert("Sorry server not running");
				}
				
				var player = new Player(playerName, Math.floor(Math.random() * 700),Math.floor(Math.random() * 550), Math.floor(Math.random() * 4));
				playerlist.push(player);				
				
				// Sockets				
				
				// Call initplayer on server		
				socket.emit("initPlayer", playerlist[0].name,playerlist[0].x, playerlist[0].y, playerlist[0].frame);
				
				// Server will fire this to update other players
				socket.on("playermove", function (pName, x, y) {
					if (playerlist) {
						for (var i in playerlist) {
							if (pName == playerlist[i].name) {
								playerlist[i].x = x;
								playerlist[i].y = y;
							}
						}
					}
				});		

				socket.on("joinAnnounce", function(pName) {
					if (pName) {
						playerJoinList.push(pName);							
						setInterval(function(){
							playerJoinList.splice(0, 1);
						},5000);
					}
				});
				
				socket.on("syncplayer", function(pName,x,y, angle, speed) {
					if (playerlist) {
						for (var i in playerlist) {
							if (pName == playerlist[i].name && playerName != playerlist[i].name) {
								playerlist[i].x = x;
								playerlist[i].y = y;
								playerlist[i].angle = angle;
								playerlist[i].speed = speed;
							}
						}
					}
				});
				
				socket.on("joinSync", function (playerlistServer,x,y) {
					if (playerlist) {				
						for (var i in playerlist) {
							if (playerName != playerlistServer[i]) {
								spawnPlayer(playerlistServer[i], x,y); 
							}					
						}			
					}
				});			
				
				socket.on("addplayer", function (playerServerList, newPlayerName) {						
					for (var i = 0; i < playerServerList.length; i++) {
						if (playerlist[0].name != playerServerList[i].name) {
							spawnPlayer(playerServerList[i].name,playerServerList[i].x,playerServerList[i].y, playerServerList[i].frame);
						}
					}
				});
								
				socket.on("setkey", function (pName, key, value) {
					if (playerlist) {
						for (var i in playerlist) {
							if (pName == playerlist[i].name && playerName != playerlist[i].name) {
								playerlist[i].keys[key] = value;
							}
						}
					}
				});
				
				socket.on('killplayer', function (otherplayername) {
					for(var i in playerlist) {
						if(playerlist[i].name == otherplayername) {
							playerlist.splice(i, 1);						
						}
					}
				});
							
				// Functionality
				function spawnPlayer(name,x,y, frame) {
					var p = new Player(name,x,y, frame);
					playerlist.push(p);
				}
				
				function syncPlayerStats(a,b,c,d,e,f) { 
					playerlist[0].topSpeed = a;	
					playerlist[0].topSpeedRev = b;
					playerlist[0].friction = c;		
					playerlist[0].acc = d;
					playerlist[0].reverse = e;				
					playerlist[0].handle = f;
				}
				
				
				
				function checkPlayerCollision() {
					var p = playerlist[0];
					
					for(index = 1; index < playerlist.length; index++) {
						var other = playerlist[index];							
						var dX = other.x - p.x ;
						var dY = other.y - p.y ;						
						
						var dis = Math.sqrt((dX*dX) + (dY*dY))		
						
						if (dis < 21) {
							// Origin Top Circle						
							var dYTop = other.y - 6 - p.y - 6;
							var dXTop = other.x - p.x;
							var disTop = Math.sqrt((dXTop*dXTop) + (dYTop*dYTop));						

							if (disTop <= 12)
								return true;	
							
							// Origin Bottom Circle
							var dYBottom = other.y + 6 - p.y + 6;
							var dXBottom = other.x -  p.x;
							var disBottom = Math.sqrt((dXBottom*dXBottom) + (dYBottom*dYBottom));							
							if (disBottom <= 13)
								return true;						
						}							
					}					
					return false;
				}
				
				
				 // Prevent Scrolling
				document.body.addEventListener('touchmove', function(event) { event.preventDefault(); }, false);				
			
				function init() {					
					canvas.height = height;
					canvas.width = width;
					
					if (canvas.getContext) {
						document.getElementById("game").appendChild(canvas);
						ctx = canvas.getContext("2d");
						ctx.save();
					}
					else alert("Unsupported");
					
					lastTime = (new (Date)).getTime();
					
					frames = totalTime = updateTime = updateFrames = 0;
					window.scrollTo(-1,0);
				}
				
				// Listeners
				var keysDown = [];
				addEventListener("keydown", function(e) {
					keysDown[e.keyCode] = true;					
				}, false);
				
				
				addEventListener("keyup", function (e) {
					delete keysDown[e.keyCode];
				
				}, false);
				
				$(window).keydown(function(e){	
					
					if(e.keyCode == 37 || e.keyCode == 65){						
						if (!playerlist[0].leftAllowed) return;
						playerlist[0].leftAllowed = false;						
						playerlist[0].keys[KEYNAMES.LEFT] = true;
						socket.emit("sendkey", playerlist[0].name,KEYNAMES.LEFT, true); // Execute keydown
						
					} else if(e.keyCode == 38 || e.keyCode == 87){
						if (!playerlist[0].upAllowed) return;
						playerlist[0].upAllowed = false;	
						playerlist[0].keys[KEYNAMES.UP] = true;
						socket.emit("sendkey", playerlist[0].name,KEYNAMES.UP, true); // Execute keydown
					} else if(e.keyCode == 39 || e.keyCode == 68){
						if (!playerlist[0].rightAllowed) return;
						playerlist[0].rightAllowed = false;	
						playerlist[0].keys[KEYNAMES.RIGHT] = true;
						socket.emit("sendkey", playerlist[0].name,KEYNAMES.RIGHT, true); // Execute keydown
					} else if (e.keyCode == 40 || e.keyCode == 83){
						if (!playerlist[0].downAllowed) return;
						playerlist[0].downAllowed = false;	
						playerlist[0].keys[KEYNAMES.DOWN] = true;
						socket.emit("sendkey", playerlist[0].name,KEYNAMES.DOWN, true); // Execute keydown
					}
					
					if(e.keyCode == 32){		 
						if (!playerlist[0].spaceAllowed) return;
						playerlist[0].spaceAllowed = false;
						playerlist[0].keys[KEYNAMES.SPACE] = true;
						socket.emit("sendkey", playerlist[0].name,KEYNAMES.SPACE, true); // Execute keydown
					}
				});
				
				$(window).keyup(function(e){
				
					if(e.keyCode == 37 || e.keyCode == 65){
						playerlist[0].leftAllowed = true;
						playerlist[0].keys[KEYNAMES.LEFT] = false;
						socket.emit("sendkey", playerlist[0].name,KEYNAMES.LEFT, false);
					} else if(e.keyCode == 38 || e.keyCode == 87){
						playerlist[0].upAllowed = true;
						playerlist[0].keys[KEYNAMES.UP] = false;
						socket.emit("sendkey", playerlist[0].name,KEYNAMES.UP, false);
					} else if(e.keyCode == 39 || e.keyCode == 68){
						playerlist[0].rightAllowed = true;
						playerlist[0].keys[KEYNAMES.RIGHT] = false;
						socket.emit("sendkey", playerlist[0].name, KEYNAMES.RIGHT, false);
					} else if (e.keyCode == 40 || e.keyCode == 83){
						playerlist[0].downAllowed = true;
						playerlist[0].keys[KEYNAMES.DOWN] = false;
						socket.emit("sendkey", playerlist[0].name, KEYNAMES.DOWN, false);
					}
					
					if (e.keyCode == 49) {
						debugToggle = !debugToggle;
					}
					
					if(e.keyCode == 32){		 
						playerlist[0].spaceAllowed = true;
						playerlist[0].keys[KEYNAMES.SPACE] = false;
						socket.emit("sendkey", playerlist[0].name, KEYNAMES.SPACE, false);
					}
				});				
					
				var GameUpdate = function(delta) {
					
					for (i = 0; i < playerlist.length; i++ ) {
						var play = playerlist[i];
			
						if (play.keys[KEYNAMES.UP]  && play.keys[KEYNAMES.SPACE] == false) { 
							if (play.speed < play.topSpeed)
								play.speed = play.speed + play.acc;						
						}else if (play.keys[KEYNAMES.DOWN]) {						
							if (play.speed > 0) {
								play.speed = play.speed - play.reverse;	
							}							
							if (play.speed <= 0 && play.speed > play.topSpeedRev) {
								play.speed = play.speed - play.reverse;
							}				
						}else {
							if (play.vx >= -0 && play.vx <= 0) {
								play.vx = 0.00;
							}
							
							if (play.vy >= -0 && play.vy <= 0) {
								play.vy = 0.00;
							}
						}
						
						if (play.keys[KEYNAMES.SPACE]) {
						
							if (Math.abs(play.speed) > play.skidSpeed) {
								play.skidding = true;
								particleEngine.add(play.x-7,play.y-12);
							}
							else 
								play.skidding = false;
						
							if (play.speed > 0 ) { // Decrease speed then
								if (play.speed > play.speed-play.brake)
									play.speed = play.speed - play.brake;
								else
									play.speed = 0;
							}
							else if (play.speed < 0 ) { // Decrease speed then
								if (play.speed > play.speed+play.brake)
									play.speed = play.speed+play.brake;
								else
									play.speed = 0;
							}
						}
						
						if (play.keys[KEYNAMES.LEFT]) {
							play.angle = play.angle - (play.handle * play.speed/play.topSpeed);
						}else if (play.keys[KEYNAMES.RIGHT]) {
							play.angle = play.angle + (play.handle * play.speed/play.topSpeed);
						}
						
						// Apply Friction
						if (play.speed > 0)
							play.speed = play.speed - play.friction;
						else if (play.speed < 0)
							play.speed = play.speed + play.friction;
							
						play.vx = Math.sin(play.angle * Math.PI / 180) * play.speed;
						play.vy = -Math.cos(play.angle * Math.PI / 180) * play.speed;					
						
						if (playerlist[0].name == play.name) {
							if (Math.abs(play.vx) >= 0.1)
								play.x = play.x + play.vx;
																	
							if (Math.abs(play.vy) >= 0.1) 
								play.y = play.y + play.vy;
						}
						else {
							if (checkPlayerCollision()) {							
								//if (checkPerPixel(playerlist[0],play)) {	
								//if (isPixelCollision(playerlist[0], play, false)) {
									//play.x -= play.vx;
								//	play.y -= play.vy;
								//	play.vx = play.vy = play.speed = -0.1;	
								
								   collisionColor = "red";
								}
								else 
									collisionColor = "cornflowerblue";
							//}
							
							if (Math.abs(play.vx) >= 0.1)
								play.x = play.x + play.vx;
															
							if (Math.abs(play.vy) >= 0.1) 
								play.y = play.y + play.vy;
						}
									
																
						if (play.x < 0) play.x = 0; 					
						if (play.y < 0) play.y = 0; 					
						if (play.x > canvas.width) play.x = canvas.width;
						if (play.y > canvas.height) play.y = canvas.height;		
						
						playerlist[i] = play;						
					}
				}		
				
				var GameLoop = function() {
					var now = Date.now();
					var delta = now - then;
					ctx.clearRect(0,0,width,height);
					
					ctx.fillStyle=collisionColor;
					ctx.fillRect(0,0,width,height);
					
					var now = (new Date()).getTime();
					deltaFPS = now-lastTime;
					lastTime = now;
					totalTime+=deltaFPS;
					frames++;
					updateTime+=deltaFPS;
					updateFrames++;
					
					GameUpdate(delta / 1000);
					particleEngine.update(delta);	
					
					// Draw stuff
					renderPlayers();					
					renderJoinList();					
					
					
					if(updateTime > 1000) {
						updateTime = 0;
						updateFrames =0;
						netTimer--;
					}
					
					if (netTimer <1) {
						socket.emit("resyncplayer",playerlist[0].name, Math.round(playerlist[0].x),Math.round(playerlist[0].y), roundNumber(playerlist[0].angle, 3), roundNumber(playerlist[0].speed,3));
						netTimer = 5; // Every 15 seconds resync player pos
					}
					
					lastCurAmount = curAmount;
					curAmount = Math.round(1000*updateFrames/updateTime);

					if (isNaN(curAmount))
						curAmount = lastCurAmount;
					
					drawString("FPS Avg: " + Math.round(1000*frames/totalTime) + " Cur: " + curAmount, 5, 20, 12);
						
					then = now;				
					requestAnimFrame(GameLoop);				
				}
				
				init();
				GameLoop();
			}
			
			function renderJoinList() {			
				for(var i=0; i < playerJoinList.length; i++) {
					drawString(playerJoinList[i] + " joined", 800, (20+ i * 20), 11);
				}
			}
						
			function renderPlayers() {
				for (var i=0; i< playerlist.length; i++) {					
					
					ctx.save();
					ctx.translate(playerlist[i].x, playerlist[i].y);
					ctx.rotate(playerlist[i].angle * Math.PI/180);							
					ctx.drawImage(carBitmap, playerlist[i].frame * 14,(playerlist[i].keys[KEYNAMES.SPACE]?1:0)*24, 14,24,-7, -12, 14, 24);
					
					//ctx.fillRect(playerlist[i].x-playerlist[i].width, playerlist[i].y-playerlist[i].height, playerlist[i].width, playerlist[i].height);
					//drawString(playerlist[i].name, playerlist[i].x + 3, playerlist[i].y, 10);

					//ctx.fillRect(0,0 , playerlist[i].width, playerlist[i].height);
			
					if (debugToggle == true) {
						
						ctx.beginPath();
						ctx.arc(0,0,12,0,2*Math.PI,false);
						ctx.lineWidth = 1;
						ctx.strokeStyle = "white";
						ctx.stroke();
						
						ctx.beginPath();
						ctx.arc(0,-6,6,0,2*Math.PI,false);
						ctx.lineWidth = 1;
						ctx.strokeStyle = "white";
						ctx.stroke();
						
						ctx.beginPath();
						ctx.arc(0,6,6,0,2*Math.PI,false);
						ctx.lineWidth = 1;
						ctx.strokeStyle = "white";
						ctx.stroke();
						ctx.restore();
					
						if (i != 0) {
							var dX = playerlist[i].x - playerlist[0].x;
							var dY = playerlist[i].y - playerlist[0].y;
							var dis = Math.sqrt((dX*dX) + (dY*dY));
							drawString(roundNumber(dis, 4), playerlist[i].x - 2, playerlist[i].y-15, 10);
						}
						
						drawString("Skidding: " + playerlist[0].skidding, 5, 35, 10);
					}
					else { ctx.restore();}
					
					ctx.fillStyle="green";
					ctx.fillRect(playerlist[i].x,playerlist[i].y,1, 1);
					
					//drawString(playerlist[i].name + " " + Math.round(playerlist[i].speed,4), playerlist[i].x, playerlist[i].y, 10);
					/*
					ctx.save();				
					ctx.translate(-playerlist[i].x - 7,-playerlist[i].y - 12);
					ctx.rotate( playerlist[i].angle * Math.PI / 180);
					ctx.drawImage(carBitmap, playerlist[i].frame * 15,0, 15,24,playerlist[i].x + playerlist[i].x, playerlist[i].y +playerlist[i].y, 15, 24);
					ctx.restore();						
					*/
					
					// Particle Engine
					particleEngine.render();
				}
			}		
			
			function isPixelCollision( first, other, isCentred )
			{
				// we need to avoid using floats, as were doing array lookups
				x  = Math.round( first.x );
				y  = Math.round( first.y );
				x2 = Math.round( other.x );
				y2 = Math.round( other.y);

				var w  = first.width,
					h  = first.height,
					w2 = other.width,
					h2 = other.height ;

				// deal with the image being centred
				if ( isCentred ) {
					// fast rounding, but positive only
					x  -= ( w/2 + 0.5) << 0
					y  -= ( h/2 + 0.5) << 0
					x2 -= (w2/2 + 0.5) << 0
					y2 -= (h2/2 + 0.5) << 0
				}

				// find the top left and bottom right corners of overlapping area
				var xMin = Math.max( x, x2 ),
					yMin = Math.max( y, y2 ),
					xMax = Math.min( x+w, x2+w2 ),
					yMax = Math.min( y+h, y2+h2 );

				// Sanity collision check, we ensure that the top-left corner is both
				// above and to the left of the bottom-right corner.
				if ( xMin >= xMax || yMin >= yMax ) {
					return false;
				}

				var xDiff = xMax - xMin,
					yDiff = yMax - yMin;

				// get the pixels out from the images
				ctx.save();
				ctx.translate(first.x, first.y);	
				ctx.rotate(first.angle * Math.PI/180);							
				ctx.drawImage(carBitmap, first.frame * 15,0, 15,24,0, 0, 15, 24);
				ctx.restore();
				
				ctx.save();
				ctx.translate(other.x, other.y);	
				ctx.rotate(other.angle * Math.PI/180);							
				ctx.drawImage(carBitmap, other.frame * 15,0, 15,24,0, 0, 15, 24);
				ctx.restore();

				var startX = first.x - 24;
				var startY = first.y - 24;
				var endX = first.x + 24;
				var endX = first.y + 24;		

				var playerPixels = ctx.getImageData(startX, startY, endX, endX).data;
				
				var startX = other.x - 24;
				var startY = other.y - 24;
				var endX = other.x + 24;
				var endX = other.y + 24;		
				var otherPixels = ctx.getImageData(startX, startY, endX, endX).data;

				// if the area is really small,
				// then just perform a normal image collision check
				if ( xDiff < 4 && yDiff < 4 ) {
					for ( var pixelX = xMin; pixelX < xMax; pixelX++ ) {
						for ( var pixelY = yMin; pixelY < yMax; pixelY++ ) {
							if (
									( playerPixels [ ((pixelX-x ) + (pixelY-y )*w )*4 + 3 ] !== 0 ) &&
									( otherPixels[ ((pixelX-x2) + (pixelY-y2)*w2)*4 + 3 ] !== 0 )
							) {
								return true;
							}
						}
					}
				} else {
					/* What is this doing?
					 * It is iterating over the overlapping area,
					 * across the x then y the,
					 * checking if the pixels are on top of this.
					 *
					 * What is special is that it increments by incX or incY,
					 * allowing it to quickly jump across the image in large increments
					 * rather then slowly going pixel by pixel.
					 *
					 * This makes it more likely to find a colliding pixel early.
					 */

					// Work out the increments,
					// it's a third, but ensure we don't get a tiny
					// slither of an area for the last iteration (using fast ceil).
					var incX = xDiff / 3.0,
						incY = yDiff / 3.0;
					incX = (~~incX === incX) ? incX : (incX+1 | 0);
					incY = (~~incY === incY) ? incY : (incY+1 | 0);

					for ( var offsetY = 0; offsetY < incY; offsetY++ ) {
						for ( var offsetX = 0; offsetX < incX; offsetX++ ) {
							for ( var pixelY = yMin+offsetY; pixelY < yMax; pixelY += incY ) {
								for ( var pixelX = xMin+offsetX; pixelX < xMax; pixelX += incX ) {
									if (
											( playerPixels [ ((pixelX-x ) + (pixelY-y )*w )*4 + 3 ] !== 0 ) &&
											( otherPixels[ ((pixelX-x2) + (pixelY-y2)*w2)*4 + 3 ] !== 0 )
									) {
										return true;
									}
								}
							}
						}
					}
				}

				return false;
			}
			function checkPerPixel(p,other) {				
				
				ctx.clearRect(0,0,canvas.width,canvas.height);			
				
				p.x = Math.round(p.x);
				p.y = Math.round(p.y);
				other.x = Math.round(other.x);
				other.y = Math.round(other.y);
				ctx.save();
				ctx.translate(p.x, p.y);	
				ctx.rotate(p.angle * Math.PI/180);							
				ctx.drawImage(carBitmap, p.frame * 15,0, 15,24,0, 0, 15, 24);
				ctx.restore();
				
				ctx.save();
				ctx.translate(other.x, other.y);	
				ctx.rotate(other.angle * Math.PI/180);							
				ctx.drawImage(carBitmap, other.frame * 15,0, 15,24,0, 0, 15, 24);
				ctx.restore();

				var startX = p.x - 24;
				var startY = p.y - 24;
				var endX = p.x + 24;
				var endX = p.y + 24;		

				var playerPixels = ctx.getImageData(startX, startY, endX, endX).data;
				var otherPixels = ctx.getImageData(startX, startY, endX, endX).data;

				for(y = 0; y < 90; y++ ) {
					for (x = 0; x < 90; x++ ){
						 if (playerPixels[(x + y * canvas.width) * 4 + 3] !== 0 && otherPixels[(x +y * canvas.width) * 4 + 3] !== 0 &&
						 		isNaN(playerPixels[(x + y * canvas.width) * 4 + 3]) == false && isNaN(otherPixels[(x +y * canvas.width) * 4 + 3]) == false
						 		) {
						 	return true;
						 }
					}
				}
				return false;
			}
		</script>
	</body>
</html>